import numpy as np
from sklearn.preprocessing import normalize
from sklearn.utils import check_random_state
from scipy.stats import truncnorm
from vectors import Vectors

class GeneratePointClusters:
    """
    Generate clusters of points on a hypersphere around specified cluster centers.

    This class generates points on a hypersphere around a set of cluster
    centers. Each cluster has a specified radius and number of points.
    Points are generated by sampling angles from a truncated normal distribution
    and then projecting them onto the hypersphere.

    Attributes
    ----------

    n_clusters : int
        The number of clusters.
    dim : int
        The dimensionality of the hypersphere.
    cluster_centers : np.ndarray
        A 2D array of unit vectors representing the cluster centers.
        Shape (n_clusters, dim).
    cluster_sizes : np.ndarray
        A 1D array specifying the number of points in each cluster.
        Shape (n_clusters,).
    cluster_radii : np.ndarray
        A 1D array specifying the radius of each cluster. Shape (n_clusters,).
        Radii should be less than pi.
    random_state : int or instance of numpy.random.RandomState
        Seed for the random number generator.
    
    """

    def __init__(self, cluster_centers, cluster_sizes, 
                            cluster_radii, random_state):
        """
        Initialize the GeneratePointClusters class.

        This constructor initializes the parameters (member variables) for generating 
        clusters of points on a hypersphere and sets up error handling of these attributes 
        using the __setattr__ method.
        
        Parameters
        ----------
        cluster_centers : np.ndarray
            A 2D array of unit vectors representing the cluster centers.
            Each row is a cluster center. The expected shape is(n_clusters, dim), where
            n_clusters is the number of clusters and dim is the
            dimensionality of the hypersphere.
        cluster_sizes : np.ndarray
            A 1D array specifying the number of points in each cluster.
            The expected shape is (n_clusters,). Must contain only integers.
        cluster_radii : np.ndarray
            A 1D array specifying the radius of each cluster.
            The expected shape is (n_clusters,). Radii should be less than pi. Must contain
            only floating point numbers.
        random_state : int or np.random.RandomState
            Seed for the random number generator.

        Raises
        ------
        ValueError
            If cluster_centers is not a 2D numpy array, or any of the rows is not an unit vector,
            or does not have at least two features (dimensions).
            If cluster_sizes is not a 1D numpy array of integers.
            If cluster_radii is not a 1D numpy array of floats, or if any of the radii is
            greater than or equal to pi.
            If random_state is not an instance of numpy.random.RandomState or an integer.
        """
        self.cluster_centers = cluster_centers
        self.cluster_sizes = cluster_sizes
        self.cluster_radii = cluster_radii
        self.random_state = check_random_state(random_state)

    def generate_points(self, truncate_at_radius = True) -> Vectors:
        """
        Generate points on a hypersphere corresponding to each prescribed cluster, 
        stacking them and then returning all the generated points as a Vectors object.

        Parameters
        ----------
        truncate_at_radius : bool, optional
            If True, truncate the angle sampling at the cluster radius.
            If False, use pi as the truncation value. By default True.
        Returns
        -------
        points: Vectors
            A Vectors object containing the generated points, 
            cluster IDs, and point IDs.
        
        Raises
        -------
        ValueError
            If any cluster radius is greater than pi.        
        """
        for clusterID in range(self.n_clusters):
            cluster_center = self.cluster_centers[clusterID]
            cluster_radius = self.cluster_radii[clusterID]
            cluster_size = self.cluster_sizes[clusterID]
            if truncate_at_radius:
                truncation_radius = cluster_radius
            else:
                truncation_radius = np.pi
            theta_r = truncnorm.rvs(0, truncation_radius, loc = 0, 
                                    scale = 0.5*cluster_radius, 
                                    size = cluster_size,
                                    seed = self.random_state)
            mat = self.random_state.uniform(
                    low = np.cos(theta_r)[:,None]/cluster_center[None,2:], 
                    high=1.0, size = (cluster_size, self.dim-2))
            c1 = 1 - np.sum(mat**2, axis=1)
            c2 = np.cos(theta_r) - np.sum(mat*cluster_center[2:], axis=1)
            sum12 = np.sum(cluster_center[:2]**2)
            x1 = c2/sum12
            x1 += (np.random_state.choice([-1,1], size=cluster_size) *
                    np.sqrt((c2**2*cluster_center[0]**2) - 
                            (sum12*(c2**2 - (c1*cluster_center[1]**2))))/sum12)
            x2 = (c2 - (x1*cluster_center[0]))/cluster_center[1]
            if clusterID == 0:
                points = Vectors(np.c_[x1, x2, mat], 
                                 clusterID = clusterID*np.ones(cluster_size, 
                                                               dtype=int),
                                 pointID = np.arange(cluster_size))
            else:
                points += Vectors(np.c_[x1, x2, mat], 
                                  clusterID = clusterID*np.ones(cluster_size, 
                                                               dtype=int),
                                  pointID = np.arange(cluster_size))

        return points    

    def __setattr__(self, name, value):

        if name == 'cluster_centers':
            if isinstance(value, np.ndarray) and (value.ndim == 2) and 
                        value.shape[1] >= 2 and 
                        np.issubdtype(value.dtype, np.floating) and
                        np.allclose(np.linalg.norm(value, axis=1), 1):
                self.__dict__[name] = value
                self.n_clusters, self.dim = np.shape(value)
            else:
                raise ValueError("cluster_centers attribute of GeneratePointClusters "+
                "must be a 2D numpy array with each row being an unit vector. "+
                "Each vector must also have more than or equal to 2 features "+
                "(or dimensions)")

        elif name == 'n_clusters':
            if value == np.shape(self.cluster_centers)[0]:
                self.__dict__[name] = value
            else:
                raise ValueError("n_clusters attribute of GeneratePointClusters "+
                "must be equal to the number of rows in the cluster_centers attribute.")

        elif name == 'dim':
            if value == np.shape(self.cluster_centers)[1]:
                self.__dict__[name] = value
            else:
                raise ValueError("dim attribute of GeneratePointClusters "+
                "must be equal to the number of columns in the cluster_centers attribute.")

        elif name == 'cluster_sizes':
            if isinstance(value, np.ndarray) and (value.ndim == 1) and 
                        np.issubdtype(value.dtype, np.integer):
                self.__dict__[name] = value
            else:
                raise ValueError("cluster_sizes attribute of GeneratePointClusters "+
                "must be a 1D numpy array of integers.")

        elif name == 'cluster_radii':
            if isinstance(value, np.ndarray) and (value.ndim == 1) and 
                        np.issubdtype(value.dtype, np.floating):
                if np.all(value<np.pi):
                    self.__dict__[name] = value
                else:
                    raise ValueError("All cluster radii must be less than pi.")
            else:
                raise ValueError("cluster_radii attribute of GeneratePointClusters "+
                "must be a 1D numpy array of floats.")

        elif name == 'random_state':
            if isinstance(value, np.random.RandomState):
                self.__dict__[name] = value
            else:
                raise ValueError("random_state attribute of GeneratePointClusters "+
                "must be an instance of np.random.RandomState.")

        else:
            self.__dict__[name] = value


